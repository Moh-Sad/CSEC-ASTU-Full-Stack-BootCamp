# CSEC-ASTU Full-Stack BootCamp

Welcome to my journey with the **CSEC-ASTU Development Division**! 🎉  
This is where I'll document my experiences, learnings, and projects from the **2-month Full-Stack Development BootCamp**.

---

## About the BootCamp

- **Duration**: 2 months  
- **Focus**: Full-Stack Development  
- **Hosted by**: CSEC-ASTU Development Division  

---

## Day 1: Learning Git and GitHub

We kicked off the BootCamp by diving into **Git** and **GitHub**:  
- **Git**: A distributed version control system used for tracking changes in source code during software development.  
- **GitHub**: A cloud-based platform for hosting Git repositories and collaborating on code.

### Commands Practiced:
- **commit**: Save changes to the local repository.  
- **push**: Upload local repository changes to a remote repository.  
- **pull**: Fetch and merge changes from a remote repository.  
- **branch**: Create and manage branches for version control.  
- **stage**: Prepare changes for committing.

---

## Day 2: BootCamp Roadmap

Today, we outlined the exciting journey ahead in the BootCamp. The curriculum covers a wide range of essential technologies for full-stack development:

### Front-End:
- **HTML:** Structure and content of web pages.
- **CSS:** Styling and presentation of web pages.
- **JavaScript:** Dynamic behavior and interactivity on web pages.
- **React:** A popular JavaScript library for building user interfaces.
- **Next.js:** A React framework for building server-rendered and statically generated websites and applications.

### Back-End:
- **Node.js:** JavaScript runtime environment for building server-side applications.
- **Express.js:** A fast and minimalist web application framework for Node.js.

### Database:
- **MySQL:** A popular open-source relational database management system.

---

## Day 3: HTML, CSS, Flexbox, and Grid

On Day 3, we learned about the **basics of HTML and CSS**, their definitions, structure, and use. Here's a quick summary:  
- **HTML**: The standard language for creating web pages, defining their structure and content.  
- **CSS**: Used for styling HTML elements, making web pages visually appealing.  

### Key Topics:
- **Flexbox and Grid**: Techniques for creating flexible and responsive layouts.  
- **Responsive Design**: Ensuring websites look good and function well on various devices and screen sizes.

We also solved **practice exercises** to strengthen our understanding of these concepts.  

---

## Day 4: Responsiveness and Media Queries

On Day 4, we focused on creating **responsive web designs** using **media queries**.  
Responsive design ensures that web pages adapt seamlessly to different screen sizes and devices.

### Key Topics Practiced:
- **Media Queries**: CSS rules to apply styles based on device characteristics like width, height, and orientation.  
- **Responsive Navbar**: Designed a navigation bar that adjusts its layout for mobile and desktop views.  
- **Responsive Cards**: Created visually appealing card components that reflow based on screen size.  

### Visuals:
Below is a screenshot of the **responsive navbar** and **card layout** we created:  
![Responsive Navbar and Card Layout](https://github.com/Moh-Sad/CSEC-ASTU-Full-Stack-BootCamp/blob/main/Front%20End%20Basics/Card/images/Screenshot.png)
We also completed a task to prepare a **responsive navbar and card layout** to consolidate our learnings.  

---

## Day 5: Basics of JavaScript and ES6 Features

Today, we dove into the basics of **JavaScript** and explored the features introduced in **ES6**. Here's a summary of what we learned:

### Key Concepts:
- **Scope in JavaScript**:  
  - **Global Scope**: Variables accessible from anywhere in the code.  
  - **Local Scope**: Variables declared within a block, function, or module, limited to that context.  

- **let vs. const vs. var**:  
  - **let**: Block-scoped, can be reassigned.  
  - **const**: Block-scoped, must be initialized and cannot be reassigned.  
  - **var**: Function-scoped, has hoisting behavior.

- **Logical Operators**:  
  - **== (Equality Operator)**: Compares values after type coercion.  
  - **=== (Strict Equality Operator)**: Compares values without type coercion (checks both value and type).  

### Tasks and Exercises:
- Solved a **swapping variables** task.  
- Practiced **verbal and practical problem-solving** by answering and implementing JavaScript-related questions.

This hands-on practice helped reinforce our understanding of JavaScript's foundational concepts. Looking forward to building more interactive applications as we progress!  

---

## Day 6: JavaScript DOM Manipulation

On Day 6, we explored the **Document Object Model (DOM)** and learned how to manipulate it using JavaScript.  

### Key Topics Covered:
- **Understanding the DOM**: The structured representation of HTML as nodes and objects.  
- **DOM Methods**:  
  - **querySelector**: Selects the first matching element.  
  - **querySelectorAll**: Selects all matching elements.  
  - **getElementById**: Selects an element by its ID.  
  - **getElementsByClassName**: Selects elements by their class name.  

- **Event Handling**:  
  - **onclick**: Handling click events dynamically.  

### Practical Exercises:
- Practiced changing **innerHTML** dynamically using **onclick** and **querySelector**.  

### Task Pending:
- We will complete a task to create an interactive feature where users input email and password details, and JavaScript validates and displays them dynamically using DOM manipulation.

---

## Day 7: UI Design and Figma Integration

Today, we focused on **UI design** by working on a Figma project and creating a **To-Do List** application using **HTML**, **CSS**, and **JavaScript**.

### Key Activities:
- **UI Design Practice**:  
  - Explored a **Figma project** to understand design workflows.  
  - Learned how to export assets and designs from Figma for implementation.  

- **Development Practice**:  
  - Built a **To-Do List application** as a hands-on project.  
  - Integrated HTML for structure, CSS for styling, and JavaScript for interactivity.  

- **Problem-Solving**:  
  - Discussed challenges faced during development.  
  - Collaborated with peers to resolve issues and referred to **Stack Overflow** for additional insights.  

### Highlights:
- It was a fantastic session that combined design and development.  
- Strengthened our understanding of the process from **design to implementation**.

---

## Day 8: Adding Functionality to the UI Project

Building on the **To-Do List application** we created on Day 7, today we focused on enhancing its functionality using **JavaScript**. The goal was to make the project more interactive, user-friendly, and visually appealing.

### Key Features Added:
1. **Interactive Buttons**:  
   - Used **event listeners** to handle user interactions.  
   - Applied **onclick handlers** for actions like adding, editing, and deleting tasks.  
   - Improved user experience with **cursor pointer styles** for better visual feedback.

2. **Dark and Light Mode Toggle**:  
   - Implemented a toggle switch that allows users to switch between dark and light modes.  
   - Used **JavaScript DOM manipulation** to dynamically update styles.  
   - Ensured the theme state persists during interactions.

3. **User-Friendly Design Enhancements**:  
   - Improved the layout and added animations for task addition and deletion.  
   - Made the project familiar and intuitive by simplifying the user flow.  

### Development Insights:
- **Problem-Solving**:  
  We encountered challenges when synchronizing dark and light modes with other elements, such as buttons and text. Through collaboration and debugging, we resolved these issues effectively.  

- **Best Practices**:  
  Learned the importance of keeping the code modular and reusable, especially when adding new features.  

### Highlights:
This session was fantastic! We successfully added meaningful functionality to our UI project, making it engaging and easy to use.  

### Gratitude:
What makes this journey more amazing is that we’re continuing with our lessons despite the final exams. A big thank you to the **CSEC ASTU Division Team** for their unwavering support and guidance!  

---

## Day 9: Reflection and Moving Forward

We finalized our semester with a session dedicated to reflection and feedback. Here’s what we covered:  
- **Feedback Session**: We evaluated the BootCamp, discussing its advantages, challenges, and areas for improvement.  
- **Future Plans**: Agreed to continue our lectures online during the semester break to maintain momentum.  

### Highlights:
- **Amazing Learning Journey**: The BootCamp was an incredible experience that enriched our skills and understanding. We’re excited to make it even better moving forward.  
- **Senior Developer’s Motivation**: A senior web developer joined us, inspiring and advising us to stay committed to our goals. Key takeaways included:  
  - Sacrificing distractions like gaming and unproductive activities.  
  - Mastering time management as a cornerstone of success.  

### Gratitude:
A heartfelt thank you to the **CSEC ASTU Division Team** and our incredible instructors **Abdurehman**, **Fasil**, and **Naol** for their guidance and support throughout this journey.

---

## Day 10: Revisiting ES6 JavaScript and Advanced Concepts

On Day 10, we revisited and deepened our understanding of **ES6 JavaScript** and explored some advanced concepts that are crucial for modern web development. Here's a summary of what we covered:

### Key Topics:
1. **Callbacks**:  
   - Learned how to use **callback functions** to handle asynchronous operations.  
   - Practiced passing functions as arguments to other functions and executing them after a task is completed.

2. **Template Literals**:  
   - Explored the use of **template literals** (backticks) for cleaner and more readable string concatenation.  
   - Practiced embedding expressions inside strings using `${}` syntax.

3. **Destructuring**:  
   - Understood how to **destructure arrays and objects** to extract values into variables more efficiently.  
   - Practiced using destructuring in function parameters and assignments.

4. **Arrow Functions**:  
   - Revisited **arrow functions** and their concise syntax.  
   - Discussed the implications of `this` in arrow functions compared to traditional functions.

### Practical Exercises:
- Solved exercises involving **callback functions** and **template literals**.  
- Implemented **destructuring** in various scenarios to extract data from arrays and objects.  

### Highlights:
This session was incredibly insightful as we revisited foundational ES6 concepts and explored their practical applications. Understanding these advanced features is crucial for writing modern, efficient, and maintainable JavaScript code.

---

## Day 11: Introduction to React and Building Simple Components

On **Day 11**, we took a significant step forward in our Full-Stack Development journey by diving into **React**, one of the most popular and powerful front-end libraries. Here's a summary of what we covered:

---

### **What is React?**
- **React** is a JavaScript library for building user interfaces, developed and maintained by **Facebook** (now Meta).  
- It allows developers to create reusable **components** to build dynamic and interactive web applications.  
- React uses a **virtual DOM** to efficiently update and render components, making it highly performant.

---

### **Key Concepts Covered:**
1. **Components**:  
   - React applications are built using **components**, which are reusable, self-contained pieces of UI.  
   - Components can be **functional** (using functions) or **class-based** (using classes).  

2. **Creating a React App**:  
   - We used **Create React App** (CRA), a tool that sets up a React project with a single command.  
   - Command:  
     ```bash
     npx create-react-app my-app
     ```  
   - This generates a boilerplate project with all the necessary configurations.

3. **JSX (JavaScript XML)**:  
   - JSX is a syntax extension for JavaScript that allows us to write HTML-like code within JavaScript.  
   - It makes React components more readable and easier to write.  

4. **React Virtual DOM**:  
   - React uses a **virtual DOM** to optimize rendering.  
   - Instead of directly manipulating the browser's DOM, React creates a lightweight copy (virtual DOM) and updates only the parts of the UI that change.  

5. **Props (Properties)**:  
   - **Props** are used to pass data from one component to another.  
   - They are read-only and help make components dynamic and reusable.

---

### **Tasks and Exercises:**
1. **Creating a React App**:  
   - We initialized a new React project using **Create React App** and explored the file structure.  

2. **Building a Simple Card Component**:  
   - Created a **Card component** that displays user information (e.g., name, image, description).  
   - Used **props** to pass data dynamically to the Card component.  

3. **Rendering Multiple Cards**:  
   - Rendered multiple instances of the Card component by mapping over an array of data.  

---

### **Code Example:**
Here’s a simple example of the **Card component** we built:

```jsx
import React from 'react';

function Card(props) {
  return (
    <div className="card">
      <img src={props.image} alt={props.name} />
      <h2>{props.name}</h2>
      <p>{props.description}</p>
    </div>
  );
}

export default Card;
```

And in the **App component**, we rendered multiple cards:

```jsx
import React from 'react';
import Card from './Card';
import './App.css';

function App() {
  const users = [
    { name: 'John Doe', image: 'https://via.placeholder.com/150', description: 'Software Developer' },
    { name: 'Jane Smith', image: 'https://via.placeholder.com/150', description: 'UI/UX Designer' },
    { name: 'Mike Johnson', image: 'https://via.placeholder.com/150', description: 'Data Scientist' },
  ];

  return (
    <div className="App">
      <h1>User Cards</h1>
      <div className="card-container">
        {users.map((user, index) => (
          <Card key={index} name={user.name} image={user.image} description={user.description} />
        ))}
      </div>
    </div>
  );
}

export default App;
```

---

### **Highlights:**
- It was exciting to see how React simplifies building dynamic and reusable UI components.
- The concept of **props** and **component-based architecture** made it clear why React is so powerful for front-end development.  
- The **virtual DOM** explanation helped us understand how React optimizes performance.  

---

### **Next Steps:**
- Dive deeper into **state management** and **event handling** in React.  
- Explore **React hooks** like `useState` and `useEffect` to add interactivity to our applications.  
- Build more complex projects to solidify our understanding of React.  

---

## Day 12: Deepening React Knowledge and Building a Tic-Tac-Toe Game

On **Day 12**, we continued our journey into **React** by diving deeper into its core concepts and applying them to build a **Tic-Tac-Toe (XO) game**. This session was particularly exciting as we explored not only conditional logic (like `if-else`) but also computational methods such as `Math.floor` to enhance our game logic. Here's a summary of what we covered:

---

### **Key Concepts Covered:**
1. **State Management with `useState`**:  
   - Learned how to use the `useState` hook to manage and update the state of our application dynamically.  
   - Applied this to track the current player's turn and the state of the game board.

2. **Event Handling in React**:  
   - Used event handlers like `onClick` to capture user interactions (e.g., clicking a cell in the Tic-Tac-Toe grid).  
   - Updated the state based on user actions to reflect changes in the UI.

3. **Conditional Rendering**:  
   - Used conditional logic to determine the winner of the game or if the game ended in a draw.  
   - Displayed messages like "Player X wins!" or "It's a draw!" based on the game state.

4. **Computational Methods**:  
   - Leveraged JavaScript's `Math.floor` and other computational methods to enhance game logic, such as generating random moves for a simple AI opponent (optional).  

5. **Component Reusability**:  
   - Designed the game board as a reusable component, making it easier to maintain and extend.  

---

### **Building the Tic-Tac-Toe Game:**
We built a simple yet functional Tic-Tac-Toe game using React. Here's an overview of the steps we followed:

1. **Setting Up the Board**:  
   - Created a 3x3 grid using a 2D array to represent the game board.  
   - Each cell in the grid was rendered as a button that users could click to place their mark (X or O).

2. **Handling Player Moves**:  
   - Used `useState` to track the current player (X or O).  
   - Updated the board state whenever a player clicked an empty cell.

3. **Checking for a Winner**:  
   - Implemented a function to check for winning conditions (e.g., three X's or O's in a row, column, or diagonal).  
   - Used conditional logic to determine if the game was over and display the result.

4. **Resetting the Game**:  
   - Added a "Reset" button to clear the board and restart the game.

---

### **Code Example:**
Here’s a simplified version of the Tic-Tac-Toe game we built:

```jsx
import React, { useState } from 'react';

function TicTacToe() {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isXNext, setIsXNext] = useState(true);

  const calculateWinner = (squares) => {
    const lines = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], 
      [0, 3, 6], [1, 4, 7], [2, 5, 8], 
      [0, 4, 8], [2, 4, 6], 
    ];

    for (let line of lines) {
      const [a, b, c] = line;
      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
        return squares[a];
      }
    }
    return null;
  };

  const handleClick = (index) => {
    if (board[index] || calculateWinner(board)) return;

    const newBoard = [...board];
    newBoard[index] = isXNext ? 'X' : 'O';
    setBoard(newBoard);
    setIsXNext(!isXNext);
  };

  const winner = calculateWinner(board);
  const status = winner ? `Winner: ${winner}` : `Next Player: ${isXNext ? 'X' : 'O'}`;

  return (
    <div className="tic-tac-toe">
      <h1>Tic-Tac-Toe</h1>
      <div className="board">
        {board.map((cell, index) => (
          <button key={index} onClick={() => handleClick(index)}>
            {cell}
          </button>
        ))}
      </div>
      <div className="status">{status}</div>
      <button onClick={() => setBoard(Array(9).fill(null))}>Reset Game</button>
    </div>
  );
}

export default TicTacToe;
```

---

### **Highlights:**
- **Hands-On Learning**: Building the Tic-Tac-Toe game helped us solidify our understanding of React's state management and event handling.  
- **Computational Logic**: Using methods like `Math.floor` added an extra layer of complexity and fun to the game.  
- **Problem-Solving**: Debugging and refining the game logic was a great exercise in critical thinking and collaboration.  

---

### **Next Steps:**
- Explore **React hooks** like `useEffect` to add more advanced features (e.g., a timer or AI opponent).  
- Learn about **React Router** to build multi-page applications.  
- Start integrating **backend technologies** like Node.js and Express.js to create full-stack applications.   

---

## Day 13: Diving into the Job Sphere Project and Learning React Design with Figma and Tailwind CSS

On Day 13, we embarked on an exciting journey into a new project called **Job Sphere**. This project focuses on building a modern, responsive web application using **React**, **Figma**, and **Tailwind CSS**. Here's a breakdown of what we covered:

### Key Topics:
1. **Introduction to Job Sphere**:  
   - Learned about the **Job Sphere** project, its objectives, and the features we aim to implement.  
   - Discussed the importance of clean and intuitive design in web applications.

2. **Designing in React from Figma**:  
   - Explored how to translate a **Figma design** into a functional React component.  
   - Practiced breaking down the Figma design into smaller, reusable components.  
   - Learned how to structure React components to match the design layout.

3. **Using Tailwind CSS with React**:  
   - Introduced **Tailwind CSS**, a utility-first CSS framework, and its benefits for rapid UI development.  
   - Learned how to integrate Tailwind CSS into a React project.  
   - Practiced using Tailwind's utility classes to style components directly in JSX.  
   - Explored responsive design techniques using Tailwind's breakpoints and grid system.

### Practical Exercises:
- Created a **React component** based on a Figma design provided for the Job Sphere project.  
- Styled the component using **Tailwind CSS** to achieve a pixel-perfect match with the Figma design.  
- Implemented responsive layouts using Tailwind's utility classes for different screen sizes.  

### Highlights:
This session was highly practical and hands-on, as we learned how to bridge the gap between design and development. By combining **Figma** for design, **React** for building components, and **Tailwind CSS** for styling, we gained a comprehensive understanding of modern web development workflows. These skills are essential for creating visually appealing and highly functional web applications.

## Day 14: Integrating Backend with Job Sphere Project and Adding Bookmark Features

On **Day 14**, we took a significant step forward in our **Job Sphere** project by integrating a **backend JSON file** to dynamically fetch product data (e.g., job details, images, descriptions) and implemented a **bookmark feature** to allow users to save jobs they're interested in. Here's a detailed breakdown of what we accomplished:

---

### **Key Features Added:**
1. **Backend Integration with JSON File**:  
   - Created a **JSON file** to act as a mock backend, storing job data such as:  
     - Job title  
     - Company name  
     - Job description  
     - Image URL  
     - Location  
     - Salary range  
   - Used **React's `useState` and `useEffect` hooks** to fetch and display this data dynamically in the Job Sphere application.

2. **Bookmark Feature**:  
   - Added a **bookmark button** for each job listing, allowing users to save jobs they're interested in.  
   - Used **state management** to toggle the bookmark status (true/false) for each job.  
   - Stored the bookmark status in the component's state and displayed a visual indicator (e.g., a filled or outlined bookmark icon) based on the user's selection.

3. **Dynamic Rendering of Job Listings**:  
   - Mapped over the JSON data to render each job listing as a **reusable React component**.  
   - Ensured the UI updates dynamically when users interact with the bookmark feature.

---

### **Implementation Details:**

#### 1. **Backend JSON File**:
We created a `jobs.json` file to store job data in a structured format:

```json
[
  {
    "id": 1,
    "title": "Frontend Developer",
    "company": "Tech Corp",
    "description": "Join our team to build amazing user interfaces!",
    "image": "https://via.placeholder.com/150",
    "location": "Remote",
    "salary": "$80,000 - $100,000",
    "isBookmarked": false
  },
  {
    "id": 2,
    "title": "Backend Developer",
    "company": "Code Masters",
    "description": "Work on scalable server-side applications.",
    "image": "https://via.placeholder.com/150",
    "location": "New York, NY",
    "salary": "$90,000 - $110,000",
    "isBookmarked": false
  }
]
```

#### 2. **Fetching Data in React**:
We used the `useEffect` hook to fetch the job data from the JSON file and store it in the component's state:

```jsx
import React, { useState, useEffect } from 'react';
import jobsData from './jobs.json'; 

function JobSphere() {
  const [jobs, setJobs] = useState([]);

  useEffect(() => {
    setJobs(jobsData);
  }, []);

  return (
    <div className="job-sphere">
      <h1>Job Listings</h1>
      {jobs.map((job) => (
        <JobCard key={job.id} job={job} />
      ))}
    </div>
  );
}
```

#### 3. **Job Card Component**:
We created a reusable `JobCard` component to display each job listing and handle the bookmark feature:

```jsx
function JobCard({ job }) {
  const [isBookmarked, setIsBookmarked] = useState(job.isBookmarked);

  const toggleBookmark = () => {
    setIsBookmarked(!isBookmarked);
  };

  return (
    <div className="job-card">
      <img src={job.image} alt={job.title} />
      <h2>{job.title}</h2>
      <h3>{job.company}</h3>
      <p>{job.description}</p>
      <p><strong>Location:</strong> {job.location}</p>
      <p><strong>Salary:</strong> {job.salary}</p>
      <button onClick={toggleBookmark}>
        {isBookmarked ? 'Bookmarked ✅' : 'Bookmark ❌'}
      </button>
    </div>
  );
}
```

#### 4. **Styling with Tailwind CSS**:
We used **Tailwind CSS** to style the job cards and make the UI visually appealing:

```jsx
<div className="job-card bg-white shadow-lg rounded-lg p-6 m-4">
  <img src={job.image} alt={job.title} className="w-24 h-24 rounded-full mx-auto" />
  <h2 className="text-xl font-bold mt-4">{job.title}</h2>
  <h3 className="text-lg text-gray-600">{job.company}</h3>
  <p className="text-gray-700 mt-2">{job.description}</p>
  <p className="text-gray-600"><strong>Location:</strong> {job.location}</p>
  <p className="text-gray-600"><strong>Salary:</strong> {job.salary}</p>
  <button
    onClick={toggleBookmark}
    className={`mt-4 px-4 py-2 rounded ${
      isBookmarked ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700'
    }`}
  >
    {isBookmarked ? 'Bookmarked ✅' : 'Bookmark ❌'}
  </button>
</div>
```

---

### **Highlights:**
- **Dynamic Data Fetching**: Learned how to integrate a backend (even a mock JSON file) to fetch and display data dynamically in a React application.  
- **Interactive Features**: Implemented a bookmark feature that enhances user interaction and engagement.  
- **Reusable Components**: Built reusable components like `JobCard` to maintain clean and modular code.  
- **Tailwind CSS**: Continued leveraging Tailwind CSS for rapid and responsive UI development.  

---

### **Next Steps:**
- **Persisting Bookmark Data**: Explore ways to persist bookmark data (e.g., using `localStorage` or a backend database).  
- **Advanced Features**: Add filtering and sorting options for job listings (e.g., by location, salary, or job type).  
- **Backend Integration**: Replace the mock JSON file with a real backend API (e.g., using Node.js and Express.js).  

This session was a fantastic blend of front-end and back-end concepts, bringing us closer to building a full-stack application.

---

##Day 15: Starting Basic Backend - Integrating Node.js and Express**

On Day 15, we began our journey into backend development by learning how to integrate **Node.js** and **Express.js**. Node.js is a runtime environment that allows us to run JavaScript on the server side, while Express.js is a popular web framework built on top of Node.js, designed to simplify the creation of web applications and APIs.

### Steps to Integrate Node.js and Express:
1. **Install Node.js**: First, we installed Node.js from the official website (https://nodejs.org). This also installs **npm** (Node Package Manager), which is used to manage dependencies.

2. **Initialize a Node.js Project**: We created a new project folder and initialized it using the command:
   ```bash
   npm init -y
   ```
   This generated a `package.json` file, which keeps track of project dependencies and scripts.

3. **Install Express**: We installed Express using npm:
   ```bash
   npm install express
   ```
   This added Express to our project's `node_modules` folder and listed it as a dependency in `package.json`.

4. **Create a Basic Server**: We created an `index.js` file and set up a basic Express server:
   ```javascript
   const express = require('express');
   const app = express();
   const port = 3000;

   app.get('/', (req, res) => {
       res.send('Hello, World!');
   });

   app.listen(port, () => {
       console.log(`Server running at http://localhost:${port}`);
   });
   ```
   This code creates a server that listens on port 3000 and responds with "Hello, World!" when the root URL (`/`) is accessed.

5. **Run the Server**: We started the server using the command:
   ```bash
   node index.js
   ```
   Then, we visited `http://localhost:3000` in the browser to see the "Hello, World!" message.

6. **Explore Express Documentation**: To deepen our understanding, we visited the official **Express.js documentation** (https://expressjs.com). The documentation provides detailed explanations of Express features, such as routing, middleware, error handling, and template engines. It also includes examples and best practices for building robust backend applications.

7. **Experiment with Routing**: We experimented with basic routing by adding more routes to our server:
   ```javascript
   app.get('/about', (req, res) => {
       res.send('About Page');
   });

   app.get('/contact', (req, res) => {
       res.send('Contact Page');
   });
   ```
   This allowed us to handle different URLs and return specific responses.

8. **Use Middleware**: We explored the concept of middleware, which are functions that process requests before they reach the final route handler. For example, we used the built-in `express.json()` middleware to parse JSON data from requests:
   ```javascript
   app.use(express.json());
   ```

9. **Plan for Future Learning**: We discussed the next steps, such as connecting to a database, handling user authentication, and building RESTful APIs. We also planned to explore advanced Express features like error handling and template engines.

10. **Reflect on the Importance of Backend Development**: We concluded the session by reflecting on the importance of backend development in creating dynamic and interactive web applications. Understanding Node.js and Express is a crucial step toward becoming a full-stack developer.

By the end of Day 15, we had a basic understanding of how to set up a Node.js and Express server, and we were excited to continue exploring backend development in the coming days.

---

## Day 16: Authentication, Authorization, JWT & File Uploads in Backend

### 🔒 Authentication & Authorization
- **Authentication**: Verifying user identity (login process)
- **Authorization**: Determining user permissions/access levels
- **Session vs Token-based** authentication approaches

### 🪙 JSON Web Tokens (JWT)
- Token structure (header, payload, signature)
- Stateless authentication benefits
- Token expiration and refresh strategies
- Secure storage methods (HTTP-only cookies vs localStorage)

### 📁 File Uploads
- Handling multipart/form-data
- Server-side processing and validation
- Storage options (local filesystem vs cloud storage)
- Security considerations

## 💻 Implementation

### JWT Setup
```javascript
// Token creation
const token = jwt.sign(
  { userId: user.id, role: user.role },
  process.env.JWT_SECRET,
  { expiresIn: '1h' }
);

// Auth middleware
const authenticate = (req, res, next) => {
  const token = req.cookies.token;
  if (!token) return res.status(401).send('Access denied');
  
  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    req.user = verified;
    next();
  } catch (err) {
    res.status(400).send('Invalid token');
  }
};
```

### File Upload Configuration
```javascript
const upload = multer({
  storage: multer.diskStorage({
    destination: 'uploads/',
    filename: (req, file, cb) => {
      cb(null, `${Date.now()}-${file.originalname}`);
    }
  }),
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files allowed!'), false);
    }
  }
});
```

## 🛠️ Features Implemented
1. User registration with password hashing
2. Login system with JWT issuance
3. Protected routes with role-based access
4. File upload endpoints with:
   - Size and type validation
   - Secure storage handling
   - Access URL generation

## 🧠 Key Learnings
- Importance of proper password hashing
- Stateless authentication advantages
- Secure token handling best practices
- File upload security considerations
- Middleware architecture patterns

## 🚧 Challenges Faced
1. Token expiration handling
2. Cross-origin cookie issues
3. File type validation edge cases
4. Role hierarchy implementation
5. Secure file access patterns

## 🔜 Next Steps
- Implement OAuth integration
- Add advanced file processing (resizing, etc.)
- Set up rate limiting for auth endpoints
- Explore production security best practices
- Implement refresh token rotation

---

Stay tuned for more updates as we continue exploring React and other full-stack technologies in the BootCamp! 🚀
